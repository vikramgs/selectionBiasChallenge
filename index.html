<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.25">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Vikram Goyal">
<meta name="dcterms.date" content="2025-11-20">

<title>Selection Bias &amp; Missing Data Challenge</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="index_files/libs/clipboard/clipboard.min.js"></script>
<script src="index_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="index_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="index_files/libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="index_files/libs/quarto-html/popper.min.js"></script>
<script src="index_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="index_files/libs/quarto-html/anchor.min.js"></script>
<link href="index_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="index_files/libs/quarto-html/quarto-syntax-highlighting-7b89279ff1a6dce999919e0e67d4d9ec.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="index_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="index_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="index_files/libs/bootstrap/bootstrap-d6a003b94517c951b2d65075d42fb01b.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Selection Bias &amp; Missing Data Challenge</h1>
<p class="subtitle lead">Creating a Statistics Meme: Write Your Own Functions</p>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Vikram Goyal </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">November 20, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<section id="selection-bias-missing-data-challenge" class="level1">
<h1>üé® Selection Bias &amp; Missing Data Challenge</h1>
<!-- ::: {.callout-important} -->
<section id="challenge-overview" class="level2">
<h2 class="anchored" data-anchor-id="challenge-overview">üìä Challenge Overview</h2>
<p><strong>Your Task:</strong> Create a four-panel statistics meme demonstrating selection bias. You‚Äôll write three Python functions yourself to complete the workflow, then assemble them into a professional meme.</p>
<!-- **Deliverables:**

1. Three Python functions you write yourself:
   - `step4_create_block_letter.py` - Create a block letter "S" matching image dimensions
   - `step5_create_masked.py` - Apply the letter mask to the stippled image
   - `create_meme.py` - Assemble all components into the four-panel meme
2. A complete `index.qmd` file that uses all functions to generate your meme
3. Your final statistics meme (as a PNG file) using your own image

**Key Learning:** This challenge teaches you to write modular Python functions and assemble them into a complete workflow. You'll learn to structure code professionally and create a memorable visual representation of selection bias.

**Repository Information:**

- **Source/Starter File:** Available in the main repository at [https://github.com/flyaflya/selectionBiasChallenge](https://github.com/flyaflya/selectionBiasChallenge)
- **Challenge Read Online:** View the challenge instructions at [https://flyaflya.github.io/selectionBiasChallenge](https://flyaflya.github.io/selectionBiasChallenge)
- **Your Submission:** Fork this challenge and create your GitHub Pages site at `https://[your-username].github.io/selectionBiasChallenge/`
:::

## The Problem: Visualizing Selection Bias

Selection bias occurs when observed data isn't representative of the population. Your meme will demonstrate this concept through visual metaphor:

- **Reality**: Your original image represents the true population
- **Your Model**: Your stippled image represents your data collection (sampling)
- **Selection Bias**: A bold letter "S" represents a systematic pattern of missing data
- **Estimate**: Stippled image with "S" mask applied shows the biased estimate‚Äîwhat you see when selection bias removes data points in a systematic pattern

**Key Concept:** Images are simply matrices‚Äî2D arrays where each value represents a pixel (0.0 = black, 1.0 = white). Your stippled image is a matrix with black dots (data points) on a white background. Selection bias removes some of these pixels (data points) in a systematic pattern (the "S"), creating a biased estimate.

**Key Insight:** When data is missing in a systematic pattern (not random), your estimates become biased. The "S" shape makes it visually obvious that the missing data follows a pattern, just like real selection bias in statistics.

## Example Output

Here's what your final meme should look like:

![Four-panel statistics meme showing Reality (original image), Your Model (stippled version), Selection Bias (letter S), and Estimate (masked stippled image)](statistics_meme.png)

**Your challenge:** Create a similar meme using your own image, with all code hidden in your `index.qmd` file. The final output should show only the meme image and a brief 1-3 sentence explanation of how it demonstrates selection bias.

## Getting Started: Repository Setup üöÄ

::: {.callout-important}
## üìÅ Repository Setup Instructions

**Step 1:** Fork the starter repository:

- Navigate to [https://github.com/flyaflya/selectionBiasChallenge](https://github.com/flyaflya/selectionBiasChallenge)
- Fork the repository to your GitHub account (this creates `https://github.com/[your-username]/selectionBiasChallenge`)

**Step 2:** Clone your forked repository locally using Cursor (or VS Code)

**Step 3:** Set up GitHub Pages:

- Go to your repository settings (click the "Settings" tab in your GitHub repository)
- Scroll down to the "Pages" section in the left sidebar
- Under "Source", select "Deploy from a branch"
- Choose "main" branch and "/ (root)" folder
- Click "Save"
- Your site will be available at: `https://[your-username].github.io/selectionBiasChallenge/`
- **Note:** It may take a few minutes for the site to become available after enabling Pages

**Step 4:** You're ready to start! Use the `index.qmd` file as your starting point.
:::

## Workflow Overview

This challenge is organized into discrete steps. Steps 1-3 are provided for you. **You must write Steps 4-5 and create_meme.py yourself:**

1. **Step 1**: Prepare black and white image (provided) ‚úÖ
2. **Step 2**: Create stippled image using blue noise stippling (provided) ‚úÖ
3. **Step 3**: Create tonal analysis (optional refinement step, provided) ‚úÖ
4. **Step 4**: Create block letter "S" matching image dimensions (**YOU WRITE THIS**) ‚ö†Ô∏è
5. **Step 5**: Create masked image by applying the letter mask to the stippled image (**YOU WRITE THIS**) ‚ö†Ô∏è
6. **create_meme.py**: Assemble all components into the four-panel meme (**YOU WRITE THIS**) ‚ö†Ô∏è

**Note:** Step 3 is optional but recommended. It helps you understand your image's brightness distribution and refine the stippling parameters in Step 2 for better results.

## Understanding the Workflow

This challenge uses a modular design where each step is implemented as a discrete function in a separate file. This structure provides several benefits:

### Modular Design Benefits

1. **Modularity**: Each step can be modified independently
2. **Reusability**: Functions can be used in other projects
3. **Testability**: Each function can be tested separately
4. **Clarity**: The workflow is easy to understand and follow
5. **Maintainability**: Changes to one step don't affect others

### Function Files

**Steps you'll use (provided):**
- **`step1_prepare_image.py`**: Image loading and preprocessing
- **`step2_create_stipple.py`**: Blue noise stippling algorithm
- **`step3_create_tonal.py`**: Tonal analysis (optional)

**Steps you'll write:**
- **`step4_create_block_letter.py`**: Block letter generation ‚ö†Ô∏è
- **`step5_create_masked.py`**: Mask application ‚ö†Ô∏è
- **`create_meme.py`**: Final assembly and visualization ‚ö†Ô∏è

**Supporting functions (provided):**
- **`importance_map.py`**: Computes importance map for stippling
- **`stippling_functions.py`**: Core stippling algorithm functions -->
</section>
<section id="step-1-prepare-image" class="level2">
<h2 class="anchored" data-anchor-id="step-1-prepare-image">Step 1: Prepare Image</h2>
<p>Load an image, convert to grayscale, and resize to appropriate dimensions while maintaining aspect ratio.</p>
<div id="cell-step1-prepare" class="cell" data-execution_count="1">
<div class="cell-output cell-output-stdout">
<pre><code>Image size: (360, 360) (no resizing needed)
Final image shape: (360, 360) (should be 2D for grayscale)</code></pre>
</div>
<div class="cell-output cell-output-display">
<div id="step1-prepare" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="index_files/figure-html/step1-prepare-output-2.png" width="442" height="470" class="figure-img"></p>
<figcaption>Original image prepared for processing</figcaption>
</figure>
</div>
</div>
</div>
</section>
<section id="step-2-create-stippled-image" class="level2">
<h2 class="anchored" data-anchor-id="step-2-create-stippled-image">Step 2: Create Stippled Image</h2>
<p>Generate a blue noise stippling pattern from the prepared image. This creates a pattern of dots that preserves visual information while maintaining good spatial distribution.</p>
<div id="cell-step2-stipple" class="cell" data-message="false" data-execution_count="2">
<div class="cell-output cell-output-stdout">
<pre><code>Importance map computed
Generating blue noise stippling pattern...
Generated 10368 stipple points
Stipple pattern shape: (360, 360)
Number of stippled points (0.0 values): 10368
Number of background points (1.0 values): 119232</code></pre>
</div>
<div class="cell-output cell-output-display">
<div id="step2-stipple" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="index_files/figure-html/step2-stipple-output-2.png" width="442" height="470" class="figure-img"></p>
<figcaption>Blue noise stippling pattern</figcaption>
</figure>
</div>
</div>
</div>
</section>
<section id="step-3-create-tonal-analysis" class="level2">
<h2 class="anchored" data-anchor-id="step-3-create-tonal-analysis">Step 3: Create Tonal Analysis</h2>
<!-- ::: {.callout-note} 
## üîß Optional Refinement Step

**Step 3 is optional** but highly recommended! It creates a box-averaged tonal analysis that helps you understand the brightness distribution across your image. Use this information to **tune the stippling parameters in Step 2** for better results.

**How to use it:**
- Analyze the tonal distribution to identify key brightness ranges
- Adjust `extreme_threshold_low` and `extreme_threshold_high` based on your image's tone distribution
- Tune `mid_tone_center` to match important features (e.g., skin tones around 0.7)
- Refine `extreme_downweight` based on how much you want to reduce stipples in extreme regions
::: -->
<p>Create a tonal analysis by dividing the image into a grid and computing average brightness in each section. This visualizes the distribution of tones and helps identify which brightness ranges are most important.</p>
<div id="cell-step3-tonal" class="cell" data-execution_count="3">
<div class="cell-output cell-output-stdout">
<pre><code>Created tonal analysis: grid 16√ó12
Tonal statistics: mean=0.668, std=0.248
Tone range: [0.056, 0.891]</code></pre>
</div>
<div class="cell-output cell-output-display">
<div id="step3-tonal" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="index_files/figure-html/step3-tonal-output-2.png" width="442" height="470" class="figure-img"></p>
<figcaption>Box-averaged tonal analysis showing brightness distribution</figcaption>
</figure>
</div>
</div>
</div>
</section>
<section id="step-4-create-block-letter-s" class="level2">
<h2 class="anchored" data-anchor-id="step-4-create-block-letter-s">Step 4: Create Block Letter ‚ÄúS‚Äù</h2>
<!-- ::: {.callout-warning} -->
<!-- ## üéØ Your Challenge: Write `step4_create_block_letter.py` -->
<p><strong>Task:</strong> Create a function <code>create_block_letter_s()</code> that generates a block letter ‚ÄúS‚Äù matching image dimensions.</p>
<!-- **Requirements:**
- Function signature: `create_block_letter_s(height: int, width: int, letter: str = "S", font_size_ratio: float = 0.9) -> np.ndarray`
- Returns a 2D numpy array (height √ó width) with values in [0, 1]
- The letter should be black (0.0) on a white background (1.0)
- The letter should be centered and scaled appropriately to fit within the image
- Use PIL/Pillow's ImageDraw or similar to render the letter

**Hints:**
- You can use `PIL.Image` and `PIL.ImageDraw` to draw text
- Try multiple font paths (e.g., system fonts) if one doesn't work
- Make the letter bold and large enough to be clearly visible
- The letter represents the "selection bias" pattern in your meme
:::

**Your code should go in a file called `step4_create_block_letter.py`.** Once you've written it, you'll use it like this: -->
</section>
<section id="step-5-create-masked-image" class="level2">
<h2 class="anchored" data-anchor-id="step-5-create-masked-image">Step 5: Create Masked Image</h2>
<!-- ::: {.callout-warning} -->
<!-- ## üéØ Your Challenge: Write `step5_create_masked.py` -->
<p><strong>Task:</strong> Create a function <code>create_masked_stipple()</code> that applies the block letter mask to the stippled image.</p>
<!-- **Requirements:**
- Function signature: `create_masked_stipple(stipple_img: np.ndarray, mask_img: np.ndarray, threshold: float = 0.5) -> np.ndarray`
- Returns a 2D numpy array with the same shape as the input images
- Where the mask is dark (below threshold), remove stipples (set to white/1.0)
- Where the mask is light (above threshold), keep the stipples as they are
- This creates the "biased estimate" by systematically removing data points

**Hints:**
- The mask image has values in [0, 1] where 0.0 = black (mask area) and 1.0 = white (keep area)
- Use numpy boolean indexing or np.where() to apply the mask
- The threshold determines what counts as "part of the mask"
:::

**Your code should go in a file called `step5_create_masked.py`.** Once you've written it, you'll use it like this: -->
</section>
<section id="create-the-final-statistics-meme" class="level2">
<h2 class="anchored" data-anchor-id="create-the-final-statistics-meme">Create the Final Statistics Meme</h2>
<!-- ::: {.callout-warning} -->
<!-- ## üéØ Your Challenge: Write `create_meme.py` -->
<p><strong>Task:</strong> Create a function <code>create_statistics_meme()</code> that assembles all four panels into a professional-looking meme.</p>
<!-- **Requirements:**
- Function signature: `create_statistics_meme(original_img: np.ndarray, stipple_img: np.ndarray, block_letter_img: np.ndarray, masked_stipple_img: np.ndarray, output_path: str, dpi: int = 150, background_color: str = "white") -> None`
- Creates a 1√ó4 layout (four panels side by side)
- Each panel should be labeled: "Reality", "Your Model", "Selection Bias", "Estimate"
- Save the result as a PNG file
- Make it look professional with good spacing, labels, and layout

**Hints:**
- Use matplotlib's `subplots()` or `GridSpec` to create the layout
- Add text labels above or below each panel
- Consider adding a border or background color
- Use high DPI (150-300) for publication quality
- Make sure all images are the same size or handle resizing appropriately
:::

**Your code should go in a file called `create_meme.py`.** Once you've written it, you'll use it like this: -->
<!-- ## Your Final Submission

### Complete Checklist

To complete this challenge, you must:

1. ‚úÖ **Use Step 1** to prepare your own image (with your own image file)
2. ‚úÖ **Use Step 2** to generate a stippled image using blue noise stippling
3. ‚≠ê **Optionally use Step 3** to analyze tonal distribution and refine Step 2 parameters (recommended)
4. ‚ö†Ô∏è **Write Step 4**: Create `step4_create_block_letter.py` to generate the block letter "S"
5. ‚ö†Ô∏è **Write Step 5**: Create `step5_create_masked.py` to apply the mask
6. ‚ö†Ô∏è **Write create_meme.py**: Create `create_meme.py` to assemble the four-panel meme
7. ‚úÖ **Create a complete `index.qmd`** that uses all functions (with code hidden)
8. ‚úÖ **Generate your final meme** using your own image
9. ‚úÖ **Include a brief explanation** (1-3 sentences) of how the meme demonstrates selection bias

### Final Output Requirements

**Important:** All code should be hidden (`echo: false`) in your final `index.qmd` output. The rendered HTML should show only:
- The final meme image
- A brief explanation (1-3 sentences) of how it demonstrates selection bias

### Template for Final Section

Here's a template for your final section: -->
<!-- ### Example Explanation

Your explanation should be 1-3 sentences. Here's an example:

> This meme demonstrates selection bias by showing how systematic missing data patterns distort our understanding of reality. The original image (Reality) represents the true population, while the stippled version (Your Model) shows our data collection. When selection bias removes data points in a systematic "S" pattern, the resulting estimate becomes biased and no longer represents the true population, just as missing data in real-world studies can lead to incorrect conclusions.

## Tips for Success

1. **Image Selection**: Choose an image with good contrast for best stippling results
2. **Use Tonal Analysis**: Run Step 3 to understand your image's brightness distribution, then refine Step 2 parameters
3. **Function Design**: Write clean, well-documented functions with clear parameter types and return values
4. **Test Incrementally**: Test each function separately before integrating them
5. **Professional Output**: Make your meme look polished with good labels, spacing, and layout
6. **Code Organization**: Keep your functions in separate `.py` files as specified
7. **Documentation**: Add docstrings to your functions explaining parameters and return values -->
</section>
<section id="final-statistics-meme" class="level2">
<h2 class="anchored" data-anchor-id="final-statistics-meme">Final Statistics Meme</h2>
<div id="cell-display-statistics-meme" class="cell" data-execution_count="8">
<div class="cell-output cell-output-display">
<div id="display-statistics-meme" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="index_files/figure-html/display-statistics-meme-output-1.png" class="img-fluid figure-img"></p>
<figcaption>Statistics meme demonstrating selection bias</figcaption>
</figure>
</div>
</div>
</div>
<section id="explanation" class="level3">
<h3 class="anchored" data-anchor-id="explanation">Explanation</h3>
<p>This meme demonstrates selection bias by showing how systematic missing data patterns distort our understanding of reality. The original image (Reality) represents the true population, while the stippled version (Your Model) shows our data collection through sampling. When selection bias removes data points in a systematic ‚ÄúS‚Äù pattern, the resulting estimate becomes biased and no longer accurately represents the true population, just as missing data in real-world studies can lead to incorrect conclusions.</p>
</section>
</section>
<section id="conclusion" class="level2">
<h2 class="anchored" data-anchor-id="conclusion">Conclusion</h2>
<p>By completing this challenge, you‚Äôll have created a memorable visual representation of selection bias that demonstrates how systematic missing data patterns can distort our understanding of reality. The skills you‚Äôve practiced‚Äîwriting modular Python functions, image processing, and creating professional visualizations‚Äîare directly applicable to real-world data analysis projects.</p>
<p>As you work with real datasets, remember the lesson of this meme: when data is missing in a systematic pattern rather than randomly, your estimates become biased. Recognizing and addressing selection bias is crucial for drawing valid conclusions from your data.</p>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "Óßã";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>